<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PeekXtract | Peek zip online</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
        <script src="./dist/protobuf.js"></script>
        <script src="./dist/xzwasm.js"></script>
        <script src="./dist/bzip2.js"></script>
        <style>
            :root {
                --bg-color: #050505;
                --card-bg: #0a0a0a;
                --text-color: #e0e0e0;
                --text-dim: #888;
                --accent-green: #2ecc71;
                --accent-blue: #00e1ff;
                --accent-red: #e74c3c;
                --border-color: #333333;
                --font-stack: 'JetBrains Mono', monospace;
                --radius: 16px;
                --system-accent-color: #2ecc71;
                --cursor-ball-color: #f39c12;
                --dim-color: rgba(46, 204, 113, 0.05);
            }

            [data-theme="light"] {
                --bg-color: #f4f4f5;
                --card-bg: #ffffff;
                --text-color: #18181b;
                --text-dim: #71717a;
                --border-color: #e4e4e7;
                --system-accent-color: #10b981;
                --dim-color: rgba(16, 185, 129, 0.1);
                --cursor-ball-color: #8b5cf6;
            }

            [data-theme="sunset"] {
                --bg-color: #1a0b14;
                --card-bg: #2d1b24;
                --text-color: #fce7f3;
                --text-dim: #be185d;
                --border-color: #500724;
                --system-accent-color: #f59e0b;
                --dim-color: rgba(245, 158, 11, 0.1);
                --cursor-ball-color: #06b6d4;
            }

            [data-theme="ocean"] {
                --bg-color: #0f172a;
                --card-bg: #1e293b;
                --text-color: #e2e8f0;
                --text-dim: #94a3b8;
                --border-color: #334155;
                --system-accent-color: #38bdf8;
                --dim-color: rgba(56, 189, 248, 0.1);
                --cursor-ball-color: #facc15;
            }

            [data-theme="forest"] {
                --bg-color: #051a0d;
                --card-bg: #0c2b16;
                --text-color: #ecfdf5;
                --text-dim: #34d399;
                --border-color: #14532d;
                --system-accent-color: #4ade80;
                --dim-color: rgba(74, 222, 128, 0.1);
                --cursor-ball-color: #ff00ff;
            }

            [data-theme="berry"] {
                --bg-color: #2e0216;
                --card-bg: #4a0424;
                --text-color: #ffe4e6;
                --text-dim: #fb7185;
                --border-color: #831843;
                --system-accent-color: #fb7185;
                --dim-color: rgba(251, 113, 133, 0.1);
                --cursor-ball-color: #a3e635;
            }

            [data-theme="royal"] {
                --bg-color: #1e0b2e;
                --card-bg: #2e1045;
                --text-color: #f3e8ff;
                --text-dim: #c084fc;
                --border-color: #581c87;
                --system-accent-color: #fbbf24;
                --dim-color: rgba(251, 191, 36, 0.1);
                --cursor-ball-color: #d8b4fe;
            }

            [data-theme="coffee"] {
                --bg-color: #271c19;
                --card-bg: #382823;
                --text-color: #e6dace;
                --text-dim: #a68b7c;
                --border-color: #5d4037;
                --system-accent-color: #d4a373;
                --dim-color: rgba(212, 163, 115, 0.1);
                --cursor-ball-color: #2dd4bf;
            }

            [data-theme="midnight"] {
                --bg-color: #020617;
                --card-bg: #0f172a;
                --text-color: #e2e8f0;
                --text-dim: #64748b;
                --border-color: #1e293b;
                --system-accent-color: #6366f1;
                --dim-color: rgba(99, 102, 241, 0.1);
                --cursor-ball-color: #39ff14;
            }

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                background-color: var(--bg-color);
                color: var(--text-color);
                font-family: var(--font-stack);
                display: flex;
                justify-content: center;
                min-height: 100vh;
                padding: 20px;
                overflow-x: hidden;
                transition: background-color 0.4s ease, color 0.4s ease;
            }

            #custom-cursor {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 21px;
                height: 21px;
                border: 2.39px solid var(--cursor-ball-color);
                box-shadow: 0 0 5px var(--cursor-ball-color);
                background-color: rgba(0, 0, 0, 0);
                backdrop-filter: blur(1px);
                border-radius: 50%;
                pointer-events: none;
                z-index: 999999;
                transform-origin: center center;
                transition: border-color 0.2s, box-shadow 0.2s;
                mix-blend-mode: normal;
                will-change: transform;
            }

            @media (pointer: fine) {
                * {
                    cursor: none !important;
                }

                #custom-cursor {
                    display: block;
                }

                body.hovering #custom-cursor {
                    box-shadow: 0 0 10px var(--cursor-ball-color);
                    background-color: var(--dim-color);
                }
            }

            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                backdrop-filter: blur(5px);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s;
            }

            .overlay.active {
                opacity: 1;
                pointer-events: all;
            }

            .modal-card {
                background: var(--card-bg);
                border: 1px solid var(--border-color);
                padding: 40px;
                border-radius: 24px;
                width: 90%;
                max-width: 500px;
                text-align: center;
                box-shadow: 0 20px 50px rgba(0,0,0,0.4);
                position: relative;
            }

            .palette-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-top: 20px;
            }

            .palette-option {
                height: 60px;
                border-radius: 12px;
                border: 2px solid transparent;
                display: flex;
                overflow: hidden;
                position: relative;
                cursor: pointer;
                transition: transform 0.2s;
            }

            .palette-option:hover {
                transform: scale(1.05);
            }

            .palette-option.active {
                border-color: var(--text-color);
                transform: scale(1.05);
            }

            .p-col {
                flex: 1;
                height: 100%;
            }

            .container {
                width: 100%;
                max-width: 1000px;
                padding-bottom: 50px;
                position: relative;
            }

            header {
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
                margin-bottom: 2px;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 20px;
                transition: border-color 0.3s ease;
            }

            .brand {
                font-size: 2rem;
                font-weight: bold;
                letter-spacing: -2px;
            }

            .header-right {
                text-align: right;
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 10px;
            }

            .meta-info {
                font-size: 0.75rem;
                color: var(--text-dim);
                text-align: right;
                line-height: 1.4;
            }

            .toolbar-container {
                display: flex;
                justify-content: flex-end;
                margin-bottom: 10px;
                margin-top: 0;
                align-items: center;
            }

            .theme-btn {
                background: transparent;
                border: 1px solid var(--border-color);
                color: var(--text-color);
                font-family: var(--font-stack);
                font-size: 0.7rem;
                padding: 6px 12px;
                cursor: pointer;
                border-radius: 6px;
                transition: all 0.2s ease;
                font-weight: bold;
            }

            .theme-btn:hover {
                border-color: var(--system-accent-color);
                color: var(--system-accent-color);
                box-shadow: 0 0 10px var(--dim-color);
            }

            .system-status {
                margin-bottom: 30px;
                position: relative;
            }

            .label {
                font-size: 0.7rem;
                color: var(--text-dim);
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 1px;
                font-weight: bold;
            }

            .status-bar {
                background-color: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: var(--radius);
                padding: 15px 20px;
                font-size: 0.9rem;
                color: var(--text-dim);
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
                width: 100%;
                z-index: 500;
            }

            .status-bar.error {
                border-color: var(--accent-red);
                color: var(--accent-red);
                background: rgba(231, 76, 60, 0.05);
                box-shadow: 0 0 15px rgba(231, 76, 60, 0.1);
            }

            .blink {
                animation: blinker 1s step-end infinite;
                color: var(--system-accent-color);
            }

            .status-bar.error .blink {
                color: var(--accent-red);
            }

            @keyframes blinker {
                50% {
                    opacity: 0;
                }
            }

            .card {
                background-color: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: var(--radius);
                padding: 25px;
                margin-bottom: 20px;
                transition: all 0.3s ease;
                position: relative;
            }

            .card:hover {
                border-color: var(--system-accent-color);
                background-color: var(--dim-color);
                box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            }

            .card-header-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 15px;
                margin-bottom: 15px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .card-title {
                font-size: 1.2rem;
                font-weight: bold;
                color: var(--text-color);
            }

            .search-input {
                background: rgba(125,125,125,0.05);
                border: 1px solid var(--border-color);
                color: var(--text-color);
                font-family: var(--font-stack);
                font-size: 0.9rem;
                padding: 12px 16px;
                width: 100%;
                border-radius: 6px;
                transition: all 0.3s;
            }

            .search-input:focus {
                outline: none;
                border-color: var(--system-accent-color);
                background: rgba(125,125,125,0.1);
            }

            .input-row {
                display: flex;
                gap: 10px;
                width: 100%;
            }

            .options-row {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-top: 15px;
                font-size: 0.8rem;
                color: var(--text-dim);
                border-top: 1px dashed var(--border-color);
                padding-top: 15px;
            }

            .option-line {
                display: flex;
                align-items: center;
                gap: 15px;
                flex-wrap: wrap;
            }

            .custom-chk {
                display: flex;
                align-items: center;
                cursor: pointer;
                user-select: none;
            }

            .custom-chk input {
                position: absolute;
                opacity: 0;
                cursor: pointer;
                height: 0;
                width: 0;
            }

            .checkmark {
                height: 16px;
                width: 16px;
                background-color: transparent;
                border: 1px solid var(--border-color);
                border-radius: 4px;
                margin-right: 8px;
                display: inline-block;
                position: relative;
                transition: all 0.2s;
            }

            .custom-chk:hover .checkmark {
                border-color: var(--system-accent-color);
            }

            .custom-chk input:checked ~ .checkmark {
                background-color: var(--system-accent-color);
                border-color: var(--system-accent-color);
            }

            .custom-chk .checkmark:after {
                content: "";
                position: absolute;
                display: none;
                left: 4px;
                top: 1px;
                width: 4px;
                height: 8px;
                border: solid #000;
                border-width: 0 2px 2px 0;
                transform: rotate(45deg);
            }

            .custom-chk input:checked ~ .checkmark:after {
                display: block;
            }

            .custom-select-container {
                position: relative;
                width: 200px;
                font-size: 0.75rem;
                font-family: var(--font-stack);
            }

            .select-head {
                background: rgba(255,255,255,0.05);
                border: 1px solid var(--border-color);
                color: var(--text-color);
                padding: 6px 10px;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .select-head:hover {
                border-color: var(--system-accent-color);
                color: var(--system-accent-color);
            }

            .select-list {
                position: absolute;
                top: 105%;
                left: 0;
                width: 100%;
                background: var(--card-bg);
                border: 1px solid var(--system-accent-color);
                border-radius: 4px;
                z-index: 999;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            }

            .select-option {
                padding: 8px 10px;
                cursor: pointer;
                transition: background 0.2s;
                border-bottom: 1px solid rgba(255,255,255,0.05);
            }

            .select-option:last-child {
                border-bottom: none;
            }

            .select-option:hover {
                background: var(--system-accent-color);
                color: var(--card-bg);
                font-weight: bold;
            }

            .proxy-alert-link {
                color: var(--text-dim);
                text-decoration: none;
                font-size: 0.7rem;
                border-bottom: 1px solid rgba(125,125,125,0.3);
                transition: all 0.2s;
                display: inline-block;
                margin-top: 5px;
                opacity: 0.8;
            }

            .proxy-alert-link:hover {
                color: var(--accent-red);
                opacity: 1;
                border-bottom-color: var(--accent-red);
            }

            .custom-proxy-input {
                width: 100%;
                background: rgba(0,0,0,0.3);
                border: 1px solid var(--border-color);
                color: var(--system-accent-color);
                font-family: var(--font-stack);
                font-size: 0.75rem;
                padding: 8px;
                border-radius: 4px;
                margin-top: 5px;
            }

            .hidden {
                display: none !important;
            }

            .sys-btn {
                background: rgba(255,255,255,0.05);
                border: 1px solid var(--border-color);
                color: var(--text-color);
                padding: 12px 20px;
                border-radius: 8px;
                font-family: var(--font-stack);
                font-size: 0.8rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
                white-space: nowrap;
            }

            .sys-btn:hover {
                border-color: var(--system-accent-color);
                color: var(--system-accent-color);
                background: rgba(125,125,125,0.1);
            }

            .sys-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .sys-btn.primary {
                border-color: var(--system-accent-color);
                color: var(--system-accent-color);
            }

            .sys-btn.primary:hover {
                background: var(--system-accent-color);
                color: #000;
            }

            .sys-btn.download-large {
                width: 100%;
                font-size: 1rem;
                padding: 15px;
                margin-top: 15px;
                background: var(--dim-color);
                border-color: var(--system-accent-color);
            }

            .file-table-container {
                max-height: 500px;
                overflow-y: auto;
                padding-right: 5px;
            }

            .file-table-container::-webkit-scrollbar {
                width: 12px;
            }

            .file-table-container::-webkit-scrollbar-track {
                background: transparent;
                margin-block: 5px; }

            .file-table-container::-webkit-scrollbar-thumb {
                background-color: var(--border-color);
                border-radius: 10px;
                border: 4px solid transparent;
                background-clip: content-box;
            }

            .file-table-container::-webkit-scrollbar-thumb:hover {
                background-color: var(--system-accent-color);
            }

            #progLog::-webkit-scrollbar {
                width: 12px;
            }

            #progLog::-webkit-scrollbar-track {
                background: transparent;
                margin-block: 5px; }

            #progLog::-webkit-scrollbar-thumb {
                background-color: var(--border-color);
                border-radius: 10px;
                border: 4px solid transparent;
                background-clip: content-box;
            }

            #progLog::-webkit-scrollbar-thumb:hover {
                background-color: var(--system-accent-color);
            }

            .file-table {
                width: 100%;
                table-layout: fixed;
                border-collapse: collapse;
                font-size: 0.85rem;
            }

            .file-table th {
                text-align: left;
                padding: 10px;
                color: var(--text-dim);
                border-bottom: 1px solid var(--border-color);
                position: sticky;
                top: 0;
                background: var(--card-bg);
                z-index: 2;
                cursor: pointer;
                user-select: none;
                transition: color 0.2s;
            }

            .file-table th:hover {
                color: var(--system-accent-color);
                background: linear-gradient(rgba(125,125,125,0.05), rgba(125,125,125,0.05)), var(--card-bg);
            }

            .sort-icon {
                font-size: 0.7rem;
                margin-left: 5px;
                opacity: 0.3;
                display: inline-block;
            }

            .file-table th.active-sort {
                color: var(--system-accent-color);
            }

            .file-table th.active-sort .sort-icon {
                opacity: 1;
            }

            .file-table td {
                padding: 8px 10px;
                border-bottom: 1px solid var(--border-color);
                color: var(--text-color);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                cursor: pointer;
                vertical-align: middle;
            }

            .file-table tr:hover td {
                background: rgba(125,125,125,0.05);
                color: var(--system-accent-color);
            }

            .col-id {
                width: 60px;
            }

            .col-name {
                width: auto;
                min-width: 150px;
            }

            .col-size {
                width: 100px;
                text-align: right;
            }

            .col-action {
                width: 70px;
                text-align: center;
            }

            @media (max-width: 600px) {
                .file-table td, .file-table th {
                    padding: 8px 4px;
                    font-size: 0.75rem;
                }

                .col-id {
                    width: 15%;
                    min-width: 35px;
                }

                .col-size {
                    width: 22%;
                    min-width: 60px;
                    text-align: right;
                }

                .col-action {
                    width: 15%;
                    min-width: 40px;
                }

                .col-name {
                    width: 48%;
                    min-width: 80px;
                }
            }

            .badge {
                font-size: 0.7rem;
                padding: 4px 8px;
                border-radius: 4px;
                border: 1px solid var(--border-color);
                display: inline-block;
            }

            .badge.green {
                border-color: var(--accent-green);
                color: var(--accent-green);
            }

            .badge.dim {
                color: var(--text-dim);
            }

            .mini-btn {
                background: transparent;
                border: 1px solid var(--border-color);
                color: var(--text-dim);
                border-radius: 4px;
                padding: 4px 8px;
                cursor: pointer;
                font-family: var(--font-stack);
                font-weight: bold;
                font-size: 0.9rem;
                transition: all 0.2s;
            }

            .mini-btn:hover {
                border-color: var(--system-accent-color);
                color: var(--system-accent-color);
                background: var(--dim-color);
            }

            .mini-btn:disabled {
                opacity: 0.2;
                cursor: default;
            }

            .detail-grid {
                display: grid;
                grid-template-columns: 100px 1fr;
                gap: 15px;
                text-align: left;
                margin-bottom: 20px;
                font-size: 0.9rem;
            }

            .detail-label {
                color: var(--text-dim);
                font-weight: bold;
            }

            .detail-val {
                color: var(--text-color);
                word-break: break-all;
            }

            footer {
                margin-top: 50px;
                padding-top: 20px;
                border-top: 1px solid var(--border-color);
                font-size: 0.7rem;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .me-container {
                display: inline-flex;
                align-items: center;
                min-height: 1rem;
            }

            .me-container::after {
                content: '‚ñà';
                margin-left: 5px;
                animation: blink 1s infinite;
                color: var(--system-accent-color);
                font-size: 0.8rem;
                line-height: 1;
            }

            a.social-link {
                color: inherit;
                text-decoration: none;
                margin-left: 15px;
                transition: color 0.3s;
            }

            a.social-link:hover {
                color: var(--system-accent-color);
            }

            .progress-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                backdrop-filter: blur(5px);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
                display: none;
            }

            .progress-box {
                background: var(--card-bg);
                border: 1px solid var(--system-accent-color);
                padding: 30px;
                border-radius: 12px;
                text-align: center;
                min-width: 300px;
                box-shadow: 0 0 30px rgba(0,0,0,0.5);
                max-width: 90%;
            }

            .spinner {
                border: 3px solid var(--card-bg);
                border-top: 3px solid var(--system-accent-color);
                border-radius: 50%;
                width: 30px;
                height: 30px;
                animation: spin 1s linear infinite;
                margin: 0 auto 15px auto;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            .p-bar-track {
                width: 100%;
                height: 6px;
                background: var(--border-color);
                border-radius: 3px;
                margin-top: 15px;
                overflow: hidden;
            }

            .p-bar-fill {
                height: 100%;
                width: 0%;
                background: var(--system-accent-color);
                transition: width 0.1s;
            }

            .payload-btn {
                width: 100%;
                background: rgba(0, 225, 255, 0.1);
                border: 1px solid var(--accent-blue);
                color: var(--accent-blue);
                margin-top: 10px;
                display: none;
            }

            .payload-btn:hover {
                background: var(--accent-blue);
                color: #000;
            }

            #backBtn {
                display: none;
                margin-right: auto;
            }

            #backBtn.visible {
                display: block;
            }

            #progLog {
                margin-top: 15px;
                height: 100px;
                background: #000;
                color: #aaa;
                font-size: 0.7rem;
                overflow-y: auto;
                padding: 10px;
                border-radius: 6px;
                text-align: left;
                font-family: monospace;
                display: none;
            }

            #system-msg {
                white-space: pre-wrap;
                word-break: break-all;
                overflow-wrap: break-word;
                flex: 1;
                margin-right: 10px;
            }
        </style>
    </head>
    <body>
        <div id="custom-cursor"></div>
        <div id="theme-overlay" class="overlay">
            <div class="modal-card">
                <h2 class="brand">VISUAL STYLE</h2>
                <div style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 20px;">SELECT INTERFACE THEME</div>
                <div class="palette-grid" id="themeGrid"></div>
                <button class="sys-btn" onclick="toggleOverlay('theme-overlay', false)" style="width: 100%; margin-top: 25px;">CLOSE</button>
            </div>
        </div>
        <div id="details-overlay" class="overlay">
            <div class="modal-card" style="width: 95%; max-width: 600px; text-align: left;">
                <div style="border-bottom: 1px solid var(--border-color); padding-bottom: 15px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="brand" style="font-size: 1.5rem;">FILE INSPECTOR</h2>
                    <button onclick="toggleOverlay('details-overlay', false)" style="background:none; border:none; color:var(--text-dim); cursor:pointer; font-size:1.5rem;">&times;</button>
                </div>
                <div class="detail-grid">
                    <div class="detail-label">FILENAME</div>
                    <div class="detail-val" id="det-name">---</div>
                    <div class="detail-label">FULL PATH</div>
                    <div class="detail-val" id="det-path" style="font-family: monospace; color: var(--system-accent-color);">---</div>
                    <div class="detail-label">SIZE</div>
                    <div class="detail-val" id="det-size">---</div>
                    <div class="detail-label" id="det-hash-label">CRC32</div>
                    <div class="detail-val" id="det-crc" style="font-family: monospace;">---</div>
                    <div class="detail-label">COMPRESSION</div>
                    <div class="detail-val" id="det-method">---</div>
                </div>
                <button id="det-download-btn" class="sys-btn download-large">INITIALIZE DOWNLOAD</button>
                <button id="det-payload-btn" class="sys-btn payload-btn">PARSE ANDROID PAYLOAD</button>
            </div>
        </div>
        <div class="overlay" id="progressModal">
            <div class="progress-box">
                <div class="spinner" id="progSpinner"></div>
                <div id="progressText" style="color: var(--text-color); margin-bottom: 5px; font-weight: bold;">PROCESSING</div>
                <div id="progressDetail" style="font-size:0.8rem; color: var(--text-dim);">Connecting...</div>
                <div class="p-bar-track">
                    <div class="p-bar-fill" id="progressBarFill"></div>
                </div>
                <div id="progLog"></div>
                <div id="progBtnContainer" style="display:none; gap:10px; margin-top:20px;">
                    <button id="progSaveBtn" class="sys-btn primary" style="flex:1;">SAVE AGAIN</button>
                    <button id="progCloseBtn" class="sys-btn" style="flex:1;">CLOSE</button>
                </div>
                <button id="progCancelParseBtn" class="sys-btn" style="display:none; width:100%; margin-top:20px; border-color:var(--accent-red); color:var(--accent-red);">CANCEL OPERATION</button>
            </div>
        </div>
        <div id="boot-overlay" class="overlay">
            <div class="modal-card" style="width: 95%; max-width: 650px; text-align: left;">
                <div style="border-bottom: 1px solid var(--border-color); padding-bottom: 15px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="brand" style="font-size: 1.5rem;">BOOT IMAGE INSPECTOR</h2>
                    <button onclick="toggleOverlay('boot-overlay', false)" style="background:none; border:none; color:var(--text-dim); cursor:pointer; font-size:1.5rem;">&times;</button>
                </div>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; margin-bottom: 20px; border: 1px solid var(--border-color);">
                    <div style="color: var(--text-dim); margin-bottom: 10px; font-weight: bold;">HEADER INFO</div>
                    <div id="boot-info-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;"></div>
                    <div id="boot-cmdline-container" style="margin-top: 15px; border-top: 1px dashed var(--border-color); padding-top: 10px;">
                        <div style="color: var(--text-dim); margin-bottom: 5px; font-weight: bold;">KERNEL CMDLINE</div>
                        <div id="boot-cmdline" style="color: var(--system-accent-color); word-break: break-all; user-select: text;">---</div>
                    </div>
                </div>
                <div class="file-table-container" style="max-height: 250px;">
                    <table class="file-table">
                        <thead>
                            <tr>
                                <th style="width: 40%;">COMPONENT</th>
                                <th style="width: 30%; text-align: right;">SIZE</th>
                                <th style="width: 30%; text-align: center;">ACTION</th>
                            </tr>
                        </thead>
                        <tbody id="boot-components-body"></tbody>
                    </table>
                </div>
                <button class="sys-btn" onclick="toggleOverlay('boot-overlay', false)" style="width: 100%; margin-top: 20px;">CLOSE INSPECTOR</button>
            </div>
        </div>
        <div class="container">
            <header>
                <div class="brand">PeekXtract.</div>
                <div class="header-right">
                    <div class="meta-info">
                        SYS.ARKT: ONLINE<br>
                        <span id="date-display">...</span>
                    </div>
                </div>
            </header>
            <div class="toolbar-container">
                <button id="backBtn" class="theme-btn" onclick="restoreZipView()">[ &lt; BACK TO ZIP ]</button>
                <div style="flex-grow: 1;"></div>
                <button id="theme-toggle" class="theme-btn" onclick="toggleOverlay('theme-overlay', true)">[ CHANGE THEME ]</button>
            </div>
            <div class="system-status">
                <div class="label">07. SYSTEM STATUS</div>
                <div class="status-bar" id="statusBar">
                    <span id="system-msg">> System Ready. Waiting for input...</span>
                    <span class="blink">‚ñà</span>
                </div>
            </div>
            <div class="card" id="inputCard">
                <div class="card-header-row">
                    <div class="card-title" style="border:none; padding:0; margin:0;">TARGET SELECTION</div>
                </div>
                <div class="input-row">
                    <input type="file" id="localPicker" style="display:none" onchange="handleLocalFile(this)">
                    <button class="sys-btn" onclick="document.getElementById('localPicker').click()" style="margin-right:5px; padding: 12px 15px;" title="Load Local Zip">üìÇ</button>
                    <input type="text" id="urlInput" class="search-input" placeholder="ENTER ZIP URL  - OR -  SELECT LOCAL FILE WITH [üìÇ]" onfocus="enterUrlEditMode()" onblur="exitUrlEditMode()" onkeypress="if(event.key === 'Enter') document.getElementById('scanBtn').click()">
                    <button id="scanBtn" class="sys-btn primary" onclick="startScan()">INIT_SCAN</button>
                </div>
                <div class="options-row">
                    <div class="option-line">
                        <label class="custom-chk">
                            <input type="checkbox" id="corsToggle" onchange="toggleProxyUI()" checked>
                            <span class="checkmark"></span>
                            ENABLE PROXY
                        
                        
                        
                        </label>
                        <div id="proxyModeDropdown" class="custom-select-container">
                            <div class="select-head" onclick="toggleCustomSelect()">
                                <span id="proxySelectLabel">ArKT Proxy (Fast)</span>
                                <span>‚ñº</span>
                            </div>
                            <div class="select-list hidden" id="proxySelectList">
                                <div class="select-option" onclick="selectProxyMode('arkt')">ArKT Proxy (Fast)</div>
                                <div class="select-option" onclick="selectProxyMode('extension')" style="color:var(--accent-blue); font-weight:bold;">Browser Extension</div>
                                <div class="select-option" onclick="selectProxyMode('heroku')">Heroku (Public/Slow)</div>
                                <div class="select-option" onclick="selectProxyMode('custom')">Custom Proxy URL</div>
                            </div>
                        </div>
                    </div>
                    <div id="customProxyContainer" class="hidden" style="width: 100%;">
                        <input type="text" id="customProxyInput" class="custom-proxy-input" placeholder="Enter Custom Proxy (e.g., https://my-cors-proxy.com/)">
                    </div>
                    <div id="herokuAlertContainer" class="hidden"></div>
                </div>
            </div>
            <div class="card hidden" id="resultsCard">
                <div class="card-header-row">
                    <div class="card-title" id="listTitle" style="border:none; padding:0; margin:0;">FILE DIRECTORY</div>
                    <div id="fileCountBadge" class="badge dim">0 FILES</div>
                </div>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="fileSearch" class="search-input" placeholder="> FILTER FILES..." oninput="filterFiles()">
                </div>
                <div class="file-table-container">
                    <table class="file-table">
                        <thead>
                            <tr>
                                <th class="col-id" onclick="sortTable('id')">
                                    ID <span id="sort-id" class="sort-icon"></span>
                                </th>
                                <th class="col-name" onclick="sortTable('name')">
                                    FILENAME <span id="sort-name" class="sort-icon"></span>
                                </th>
                                <th class="col-size" onclick="sortTable('size')">
                                    SIZE <span id="sort-size" class="sort-icon"></span>
                                </th>
                                <th class="col-action">DL</th>
                            </tr>
                        </thead>
                        <tbody id="fileTableBody"></tbody>
                    </table>
                </div>
                <div style="margin-top: 10px; font-size: 0.7rem; color: var(--text-dim); text-align: center;">> CLICK HEADERS TO SORT | CLICK ROW FOR DETAILS | CLICK [‚á©] FOR QUICK DOWNLOAD
            </div>
            </div>
            <footer>
                <div class="me-section">
                    <span class="me-label">SYS.ME ::</span>
                    <span id="me-display" class="me-container"></span>
                </div>
                <div>
                    <a href="https://github.com/ArKT-7" class="social-link">GITHUB</a>
                </div>
            </footer>
        </div>
        <script>

            const ARKT_PROXY = "https://peekxtract.arkt.workers.dev/";
            const HEROKU_PROXY = "https://cors-anywhere.herokuapp.com/";
            let currentProxyMode = 'arkt';
            let globalAbortController = null;
            let activeBlobUrl = null;
            let LOCAL_FILE = null;

            function enterUrlEditMode() {
                const uiInput = document.getElementById('urlInput');
                if (LOCAL_FILE) {
                    uiInput.value = "";
                    uiInput.classList.remove('read-only-look');
                }
                document.querySelector('.options-row').classList.remove('hidden');
            }

            function exitUrlEditMode() {
                const uiInput = document.getElementById('urlInput');
                const val = uiInput.value.trim();
                if (val === "" && LOCAL_FILE) {
                    uiInput.value = `[LOCAL FILE] ${LOCAL_FILE.name}`;
                    document.querySelector('.options-row').classList.add('hidden');
                }
            }

            function handleLocalFile(input) {
                if (input.files && input.files[0]) {
                    LOCAL_FILE = input.files[0];
                    const uiInput = document.getElementById('urlInput');
                    uiInput.value = `[LOCAL FILE] ${LOCAL_FILE.name}`;
                    document.querySelector('.options-row').classList.add('hidden');
                    setSystemMsg(`Local file selected: ${LOCAL_FILE.name} (${formatSize(LOCAL_FILE.size)})`);
                    document.getElementById('resultsCard').classList.add('hidden');
                    startScan();
                }
            }

            function resetUrlMode() {
                if (LOCAL_FILE) {
                    LOCAL_FILE = null;
                    const uiInput = document.getElementById('urlInput');
                    uiInput.value = "";
                    uiInput.readOnly = false;
                    uiInput.style.opacity = "1";
                    uiInput.style.cursor = "text";
                    document.getElementById('localPicker').value = "";
                    document.querySelector('.options-row').classList.remove('hidden');
                    setSystemMsg("> Switched to URL Mode. Waiting for input...");
                }
            }

            function toggleProxyUI() {
                const isProxyEnabled = document.getElementById('corsToggle').checked;
                const dropdown = document.getElementById('proxyModeDropdown');
                const customInput = document.getElementById('customProxyContainer');
                const herokuAlert = document.getElementById('herokuAlertContainer');

                if (isProxyEnabled) {
                    dropdown.classList.remove('hidden');
                    updateProxyDisplay();
                } else {
                    dropdown.classList.add('hidden');
                    customInput.classList.add('hidden');
                    herokuAlert.classList.add('hidden');
                }
            }

            function toggleCustomSelect() {
                document.getElementById('proxySelectList').classList.toggle('hidden');
            }

            function selectProxyMode(mode) {
                currentProxyMode = mode;
                const label = document.getElementById('proxySelectLabel');
                if (mode === 'arkt') {
                    label.textContent = "ArKT Proxy (Fast)";
                } else if (mode === 'heroku') {
                    label.textContent = "Heroku (Public/Slow)";
                } else if (mode === 'custom') {
                    label.textContent = "Custom Proxy URL";
                } else if (mode === 'extension') {
                    label.textContent = "Browser Extension";
                }

                document.getElementById('proxySelectList').classList.add('hidden');
                updateProxyDisplay();
            }

            function updateProxyDisplay() {
                const customInput = document.getElementById('customProxyContainer');
                const herokuAlert = document.getElementById('herokuAlertContainer');
                customInput.classList.add('hidden');
                herokuAlert.classList.add('hidden');

                if (currentProxyMode === 'custom') {
                    customInput.classList.remove('hidden');
                } else if (currentProxyMode === 'heroku') {
                    herokuAlert.innerHTML = `
                        <a href="https://cors-anywhere.herokuapp.com/corsdemo" target="_blank" class="proxy-alert-link" style="color:var(--system-accent-color); border-color:var(--system-accent-color);">
                            [ ‚ö†Ô∏è REQUIRED: Click here to open Heroku &amp; request temporary access ]
                        </a>`;
                    herokuAlert.classList.remove('hidden');
                } else if (currentProxyMode === 'extension') {
                    herokuAlert.innerHTML = `
                        <a href="https://chromewebstore.google.com/detail/odkadbffomicljkjfepnggiibcjmkogc" target="_blank" class="proxy-alert-link" style="color:var(--system-accent-color); border-color:var(--system-accent-color);">
                            [ ‚ö†Ô∏è REQUIRED: Click here to install 'CORS Unblock' Extension &amp; Then enable it ]
                        </a>`;
                    herokuAlert.classList.remove('hidden');
                }
            }

            window.addEventListener('click', (e) => {
                if (!e.target.closest('.custom-select-container')) {
                    document.getElementById('proxySelectList').classList.add('hidden');
                }
            }
            );

            document.getElementById('urlInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('scanBtn').click();
                }
            });

            function fixGithubUrl(url) {
                try {
                    const blobPattern = /^https?:\/\/(?:www\.)?github\.com\/([^\/]+)\/([^\/]+)\/blob\/(.+)$/i;
                    if (blobPattern.test(url)) {
                        return url.replace(blobPattern, "https://raw.githubusercontent.com/$1/$2/$3");
                    }
                    return url;
                } catch (e) {
                    return url;
                }
            }

            function getTargetUrl(originalUrl) {
                let finalUrl = fixGithubUrl(originalUrl);
                const isProxyEnabled = document.getElementById('corsToggle').checked;
                if (!isProxyEnabled)
                    return finalUrl;
                if (currentProxyMode === 'extension') {
                    return finalUrl;
                }

                if (currentProxyMode === 'arkt') {
                    return ARKT_PROXY + finalUrl;
                } else if (currentProxyMode === 'heroku') {
                    return HEROKU_PROXY + finalUrl;
                } else {
                    let custom = document.getElementById('customProxyInput').value.trim();
                    if (!custom)
                        return finalUrl;
                    if (!custom.endsWith('/'))
                        custom += '/';
                    return custom + finalUrl;
                }
            }

            function getRequestHeaders(rangeStart, rangeEnd) {
                const headers = {};

                if (rangeStart !== undefined && rangeEnd !== undefined) {
                    headers['Range'] = `bytes=${rangeStart}-${rangeEnd}`;
                } else if (rangeStart === '0-0') {
                    headers['Range'] = 'bytes=0-0';
                }

                const isProxyEnabled = document.getElementById('corsToggle').checked;
                if (isProxyEnabled && currentProxyMode !== 'extension') {
                    headers['X-Requested-With'] = 'XMLHttpRequest';
                }

                return headers;
            }

            const crcTable = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let k = 0; k < 8; k++)
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                crcTable[i] = c;
            }

            function crc32(buffer) {
                const bytes = new Uint8Array(buffer);
                let crc = -1;
                for (let i = 0; i < bytes.length; i++) {
                    crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
                }
                return (crc ^ -1) >>> 0;
            }

            const THEMES = [{
                id: 'dark',
                name: 'Cyber Dark',
                colors: ['#050505', '#2ecc71']
            }, {
                id: 'light',
                name: 'Clean Light',
                colors: ['#ffffff', '#10b981']
            }, {
                id: 'sunset',
                name: 'Sunset Vibe',
                colors: ['#2d1b24', '#f59e0b']
            }, {
                id: 'ocean',
                name: 'Deep Ocean',
                colors: ['#0f172a', '#38bdf8']
            }, {
                id: 'forest',
                name: 'Neon Forest',
                colors: ['#051a0d', '#4ade80']
            }, {
                id: 'berry',
                name: 'Wild Berry',
                colors: ['#4a0424', '#fb7185']
            }, {
                id: 'royal',
                name: 'Royal Gold',
                colors: ['#1e0b2e', '#fbbf24']
            }, {
                id: 'coffee',
                name: 'Dark Roast',
                colors: ['#271c19', '#d4a373']
            }, {
                id: 'midnight',
                name: 'Midnight',
                colors: ['#020617', '#6366f1']
            }, ];

            function applyTheme(themeId) {
                document.documentElement.setAttribute('data-theme', themeId);
                localStorage.setItem('peek_theme', themeId);
                const options = document.querySelectorAll('.palette-option');
                options.forEach(el => el.classList.toggle('active', el.dataset.theme === themeId));
                const btn = document.getElementById('theme-toggle');
                const current = THEMES.find(t => t.id === themeId);
                if (btn && current)
                    btn.textContent = `[THEME: ${current.name.toUpperCase()}]`;
            }

            function generateThemeGrid() {
                const grid = document.getElementById('themeGrid');
                grid.innerHTML = '';
                THEMES.forEach(t => {
                    const div = document.createElement('div');
                    div.className = 'palette-option';
                    div.dataset.theme = t.id;
                    div.onclick = () => applyTheme(t.id);
                    div.innerHTML = `
                <div class="p-col" style="background:${t.colors[0]}"></div>
                <div class="p-col" style="background:${t.colors[1]}"></div>
                <div style="position:absolute; bottom:5px; left:0; width:100%; text-align:center; font-size:0.6rem; color:#fff; text-shadow:0 1px 2px #000; font-weight:bold;">${t.name.toUpperCase()}</div>
            `;
                    grid.appendChild(div);
                }
                );
            }

            function toggleOverlay(id, show) {
                const el = document.getElementById(id);
                if (show)
                    el.classList.add('active');
                else
                    el.classList.remove('active');
            }

            const EOCD_SIG = 0x06054b50;
            const CD_SIG = 0x02014b50;
            const LFH_SIG = 0x04034b50;
            const ZIP64_EOCD_LOCATOR_SIG = 0x07064b50;
            const ZIP64_EOCD_SIG = 0x06064b50;
            let CURRENT_URL = "";
            let FILE_LIST = [];
            let sortState = {
                key: 'id',
                dir: 'asc'
            };
            let fileSize = 0;
            let PARTITIONS = [];
            let PAYLOAD_INFO = null;
            let IS_PAYLOAD_VIEW = false;

            function setSystemMsg(msg, isError=false) {
                const el = document.getElementById('system-msg');
                const bar = document.getElementById('statusBar');
                const fullMsg = "> " + msg;
                el.textContent = fullMsg;

                if (isError) {
                    console.error(fullMsg);
                    bar.classList.add('error');
                    setTimeout( () => bar.classList.remove('error'), 3000);
                } else {
                    console.log(fullMsg);
                    bar.classList.remove('error');
                }
            }

            function formatSize(bytes) {
                if (bytes === 0)
                    return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            async function fetchBytes(url, start, end, signal=null) {
                if (LOCAL_FILE) {
                    const slice = LOCAL_FILE.slice(start, end + 1);
                    return await slice.arrayBuffer();
                }
                const target = getTargetUrl(url);
                const options = {
                    headers: getRequestHeaders(start, end)
                };
                if (signal)
                    options.signal = signal;

                const response = await fetch(target, options);
                if (start !== undefined && response.status === 200) {
                    throw new Error("Proxy Error: Server returned 200 OK (Full File). Range/Seeking not supported.");
                }

                if (!response.ok && response.status !== 206)
                    throw new Error(`HTTP ${response.status}`);
                return await response.arrayBuffer();
            }

            async function fetchBytesWithProgress(url, start, end, onProgress) {
                if (LOCAL_FILE) {
                    const total = end - start + 1;
                    let loaded = 0;
                    const chunkSize = 1024 * 1024 * 5;
                    let offset = start;
                    let finalBuffer = new Uint8Array(total);

                    while (offset <= end) {
                        const chunkEnd = Math.min(offset + chunkSize, end + 1);
                        const slice = LOCAL_FILE.slice(offset, chunkEnd);
                        const buf = await slice.arrayBuffer();
                        const chunkArr = new Uint8Array(buf);

                        finalBuffer.set(chunkArr, loaded);
                        loaded += chunkArr.length;
                        offset += chunkArr.length;

                        if (onProgress)
                            onProgress(loaded, total);
                        await new Promise(r => setTimeout(r, 0));
                    }
                    return finalBuffer.buffer;
                }

                const target = getTargetUrl(url);
                const response = await fetch(target, {
                    headers: getRequestHeaders(start, end)
                });
                if (!response.ok && response.status !== 206)
                    throw new Error(`HTTP ${response.status}`);

                const reader = response.body.getReader();
                const total = end - start + 1;
                let received = 0;
                let chunks = [];

                while (true) {
                    const {done, value} = await reader.read();
                    if (done)
                        break;
                    chunks.push(value);
                    received += value.length;
                    if (onProgress)
                        onProgress(received, total);
                }

                let all = new Uint8Array(received);
                let pos = 0;
                for (let chunk of chunks) {
                    all.set(chunk, pos);
                    pos += chunk.length;
                }
                return all.buffer;
            }

            async function resolveUrlAndSize(url) {
                const fixedUrl = fixGithubUrl(url);
                const target = getTargetUrl(fixedUrl);

                setSystemMsg(`Connecting to ${target}...`);

                try {
                    const headers = getRequestHeaders();
                    const response = await fetch(target, {
                        method: 'HEAD',
                        headers: headers
                    });

                    const len = response.headers.get('content-length');
                    if (response.ok && len && !isNaN(len) && parseInt(len) > 0) {
                        return {
                            url: fixedUrl,
                            size: parseInt(len)
                        };
                    }
                } catch (e) {
                    console.warn("HEAD request failed or blocked, proceeding to Range test...", e);
                }

                try {
                    const response = await fetch(target, {
                        headers: getRequestHeaders('0-0')
                    });

                    if (response.status === 403 || response.status === 404)
                        throw new Error(`HTTP ${response.status}: Access Denied or File Not Found.`);

                    if (response.status === 200) {
                        const len = response.headers.get('content-length');
                        if (len && parseInt(len) > 1000) {
                            return {
                                url: fixedUrl,
                                size: parseInt(len)
                            };
                        }
                        throw new Error("Proxy Error: Server returned 200 OK (Full File) but size is missing.");
                    }

                    const cr = response.headers.get('content-range');
                    if (cr) {
                        const total = cr.split('/')[1];
                        if (total && total !== '*' && !isNaN(total)) {
                            return {
                                url: fixedUrl,
                                size: parseInt(total)
                            };
                        }
                    }

                    const cl = response.headers.get('content-length');
                    if (cl && parseInt(cl) > 100000) {
                        return {
                            url: fixedUrl,
                            size: parseInt(cl)
                        };
                    }

                    throw new Error("Could not detect file size. Headers missing.");

                } catch (e) {
                    if (e.name === 'TypeError' && e.message === 'Failed to fetch') {

                        if (currentProxyMode === 'extension') {
                            throw new Error("Connection Failed. Is the 'CORS Unblock' extension enabled?");
                        } else if (currentProxyMode === 'arkt') {
                            throw new Error("Connection Failed. The ArKT Proxy may be blocked by your network.");
                        }

                        throw new Error("Connection Failed. CORS Blocked or Network Error.");
                    }
                    throw e;
                }
            }

            async function startScan() {
                const uiInput = document.getElementById('urlInput');
                const inputVal = uiInput.value.trim();

                if (inputVal !== "" && !inputVal.startsWith("[LOCAL FILE]")) {
                    LOCAL_FILE = null;
                    document.getElementById('localPicker').value = "";
                }

                if (!inputVal && !LOCAL_FILE) {
                    setSystemMsg("ERROR: NO FILE OR URL SELECTED", true);
                    return;
                }
                try {
                    document.getElementById('scanBtn').disabled = true;
                    document.getElementById('resultsCard').classList.add('hidden');
                    FILE_LIST = [];
                    IS_PAYLOAD_VIEW = false;

                    if (LOCAL_FILE) {
                        CURRENT_URL = "LOCAL_FILE";
                        fileSize = LOCAL_FILE.size;
                        setSystemMsg(`Local Mode: ${LOCAL_FILE.name}. Reading Directory...`);
                    } else {
                        const {url, size} = await resolveUrlAndSize(inputVal);
                        CURRENT_URL = url;
                        fileSize = size;
                        setSystemMsg(`File Size: ${formatSize(size)}. Finding Directory...`);
                    }

                    const size = fileSize;
                    const searchSize = Math.min(65536, size);
                    const buffer = await fetchBytes(CURRENT_URL, size - searchSize, size - 1);
                    const view = new DataView(buffer);
                    let eocdOffset = -1;
                    for (let i = view.byteLength - 22; i >= 0; i--) {
                        if (view.getUint32(i, true) === EOCD_SIG) {
                            eocdOffset = i;
                            break;
                        }
                    }
                    if (eocdOffset === -1)
                        throw new Error("Invalid ZIP format (EOCD Signature missing).");

                    let cdSize = view.getUint32(eocdOffset + 12, true);
                    let cdOffset = view.getUint32(eocdOffset + 16, true);

                    if (cdOffset === 0xFFFFFFFF || cdSize === 0xFFFFFFFF) {
                        console.log("ZIP64 indicators found in EOCD. Searching for ZIP64 Locator...");

                        let zip64LocatorOffset = eocdOffset - 20;
                        let zip64EocdOffset = -1;

                        if (zip64LocatorOffset >= 0 && view.getUint32(zip64LocatorOffset, true) === ZIP64_EOCD_LOCATOR_SIG) {
                            const low = view.getUint32(zip64LocatorOffset + 8, true);
                            const high = view.getUint32(zip64LocatorOffset + 12, true);
                            zip64EocdOffset = (high * 4294967296) + low;
                            console.log("Found ZIP64 Locator. EOCD Record is at:", zip64EocdOffset);
                        } else {
                            console.warn("ZIP64 indicators present but Locator not found at expected position.");
                        }

                        if (zip64EocdOffset !== -1) {
                            const zip64RecordBuffer = await fetchBytes(CURRENT_URL, zip64EocdOffset, zip64EocdOffset + 55);
                            const zip64View = new DataView(zip64RecordBuffer);
                            if (zip64View.getUint32(0, true) === ZIP64_EOCD_SIG) {
                                cdSize = Number(zip64View.getBigUint64(40, true));
                                cdOffset = Number(zip64View.getBigUint64(48, true));
                            }

                            const sizeBig = zip64View.getBigUint64(40, true);
                            const offsetBig = zip64View.getBigUint64(48, true);
                            cdSize = Number(sizeBig);
                            cdOffset = Number(offsetBig);
                            console.log(`ZIP64 CD Size: ${cdSize}, Offset: ${cdOffset}`);
                        }
                    }

                    setSystemMsg(`Reading Central Directory...`);
                    const cdBuffer = await fetchBytes(CURRENT_URL, cdOffset, cdOffset + cdSize - 1);
                    const cdView = new DataView(cdBuffer);
                    let offset = 0
                      , index = 1;

                    while (offset < cdView.byteLength) {
                        if (offset + 46 > cdView.byteLength)
                            break;
                        const sig = cdView.getUint32(offset, true);
                        if (sig !== CD_SIG)
                            break;
                        const method = cdView.getUint16(offset + 10, true);
                        const compSize = cdView.getUint32(offset + 20, true);
                        const uncompSize = cdView.getUint32(offset + 24, true);
                        const nameLen = cdView.getUint16(offset + 28, true);
                        const extraLen = cdView.getUint16(offset + 30, true);
                        const commentLen = cdView.getUint16(offset + 32, true);
                        const localOffset = cdView.getUint32(offset + 42, true);
                        const crc = cdView.getUint32(offset + 16, true);
                        const name = new TextDecoder().decode(new Uint8Array(cdBuffer,offset + 46,nameLen));

                        let finalCompSize = compSize;
                        let finalUncompSize = uncompSize;
                        let finalLocalOffset = localOffset;

                        if (extraLen > 0) {
                            const extraDataStart = offset + 46 + nameLen;
                            const extraData = new Uint8Array(cdBuffer,extraDataStart,extraLen);
                            const extraView = new DataView(cdBuffer,extraDataStart,extraLen);

                            let extraOff = 0;
                            while (extraOff + 4 <= extraLen) {
                                const headerId = extraView.getUint16(extraOff, true);
                                const dataSize = extraView.getUint16(extraOff + 2, true);

                                if (headerId === 0x0001) {
                                    let dataOff = extraOff + 4;
                                    if (uncompSize === 0xFFFFFFFF) {
                                        if (dataOff + 8 <= extraLen + extraOff) {
                                            finalUncompSize = Number(extraView.getBigUint64(dataOff, true));
                                            dataOff += 8;
                                        }
                                    }
                                    if (compSize === 0xFFFFFFFF) {
                                        if (dataOff + 8 <= extraLen + extraOff) {
                                            finalCompSize = Number(extraView.getBigUint64(dataOff, true));
                                            dataOff += 8;
                                        }
                                    }
                                    if (localOffset === 0xFFFFFFFF) {
                                        if (dataOff + 8 <= extraLen + extraOff) {
                                            finalLocalOffset = Number(extraView.getBigUint64(dataOff, true));
                                            dataOff += 8;
                                        }
                                    }
                                }
                                extraOff += 4 + dataSize;
                            }
                        }

                        if (finalUncompSize > 0 && !name.endsWith('/')) {
                            FILE_LIST.push({
                                id: index++,
                                name,
                                size: finalUncompSize,
                                compSize: finalCompSize,
                                method,
                                localOffset: finalLocalOffset,
                                crc
                            });
                        }
                        offset += 46 + nameLen + extraLen + commentLen;
                    }

                    const payload = FILE_LIST.find(f => f.name.endsWith('payload.bin'));
                    if (payload) {
                        renderFiles(FILE_LIST);
                        document.getElementById('resultsCard').classList.remove('hidden');
                        setSystemMsg("Auto-detect: payload.bin found. Initializing...");

                        await initPayloadMode(payload, true);

                    } else {
                        renderFiles(FILE_LIST);
                        document.getElementById('resultsCard').classList.remove('hidden');
                        setSystemMsg(`Scan Complete. Found ${FILE_LIST.length} files.`);
                        document.getElementById('fileCountBadge').textContent = `${FILE_LIST.length} FILES`;
                    }

                } catch (e) {
                    setSystemMsg(`ERROR: ${e.message}`, true);
                } finally {
                    document.getElementById('scanBtn').disabled = false;
                }
            }

            function sortTable(key) {
                if (sortState.key === key) {
                    sortState.dir = sortState.dir === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.key = key;
                    sortState.dir = 'asc';
                }

                ['id', 'name', 'size'].forEach(k => {
                    const icon = document.getElementById(`sort-${k}`);
                    if (icon) {
                        const th = icon.parentElement;
                        th.classList.remove('active-sort');
                        icon.textContent = '';
                        if (k === sortState.key) {
                            th.classList.add('active-sort');
                            icon.textContent = sortState.dir === 'asc' ? '‚ñ≤' : '‚ñº';
                        }
                    }
                }
                );
                filterFiles();
            }

            function applySort(list) {
                const sorted = [...list];
                sorted.sort( (a, b) => {
                    let valA, valB;

                    if (IS_PAYLOAD_VIEW) {
                        if (sortState.key === 'name') {
                            valA = a.partitionName.toLowerCase();
                            valB = b.partitionName.toLowerCase();
                        } else if (sortState.key === 'size') {
                            valA = toNum(a.newPartitionInfo?.size || 0);
                            if (!valA && a.operations)
                                valA = a.operations.length * 4096;
                            valB = toNum(b.newPartitionInfo?.size || 0);
                            if (!valB && b.operations)
                                valB = b.operations.length * 4096;
                        } else {
                            valA = PARTITIONS.indexOf(a);
                            valB = PARTITIONS.indexOf(b);
                        }
                    } else {

                        if (sortState.key === 'name') {
                            valA = a.name.toLowerCase();
                            valB = b.name.toLowerCase();
                        } else if (sortState.key === 'size') {
                            valA = a.size;
                            valB = b.size;
                        } else {
                            valA = a.id;
                            valB = b.id;
                        }
                    }

                    if (valA < valB)
                        return sortState.dir === 'asc' ? -1 : 1;
                    if (valA > valB)
                        return sortState.dir === 'asc' ? 1 : -1;
                    return 0;
                }
                );

                return sorted;
            }

            function filterFiles() {
                const term = document.getElementById('fileSearch').value.toLowerCase();
                let list;

                if (IS_PAYLOAD_VIEW) {
                    list = PARTITIONS.filter(p => p.partitionName.toLowerCase().includes(term));
                    list = applySort(list);
                    renderPayloadTable(list);
                } else {
                    list = FILE_LIST.filter(f => f.name.toLowerCase().includes(term));
                    list = applySort(list);
                    renderFiles(list);
                }
            }

            function renderFiles(list) {
                document.getElementById('listTitle').innerText = "FILE DIRECTORY";
                document.getElementById('backBtn').classList.remove('visible');
                document.getElementById('fileCountBadge').innerText = `${list.length} FILES`;

                const tbody = document.getElementById('fileTableBody');
                const totalCount = list.length;

                tbody.innerHTML = list.map( (f, index) => {
                    const isSupported = f.method === 0 || f.method === 8;

                    let displayId;
                    if (sortState.dir === 'desc') {
                        displayId = totalCount - index;
                    } else {
                        displayId = index + 1;
                    }

                    return `
            <tr onclick="openDetails(${f.id})">
                <td class="col-id">#${String(displayId).padStart(3, '0')}</td>
                <td class="col-name" title="${f.name}" style="${f.name.endsWith('payload.bin') ? 'color:var(--accent-blue);font-weight:bold;' : ''}">${f.name}</td>
                <td class="col-size">${formatSize(f.size)}</td>
                <td class="col-action">
                    <button class="mini-btn" onclick="event.stopPropagation(); downloadFile(${f.id})" ${!isSupported ? 'disabled' : ''}>‚á©</button>
                </td>
            </tr>
            `;
                }
                ).join('');
            }

            function openDetails(id) {
                if (IS_PAYLOAD_VIEW)
                    return openPartitionDetails(id);

                const label = document.getElementById('det-hash-label');
                if (label)
                    label.textContent = "CRC32";

                const file = FILE_LIST.find(f => f.id === id);
                if (!file)
                    return;

                document.getElementById('det-name').textContent = file.name.split('/').pop();
                document.getElementById('det-path').textContent = file.name;

                document.getElementById('det-size').innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:2px;">
                        <span>${formatSize(file.size)} <span style="color:var(--text-dim); font-size:0.8em;">(Actual)</span></span>
                        <span style="color:var(--system-accent-color); font-size:0.9em;">${formatSize(file.compSize)} <span style="opacity:0.7; font-size:0.9em;">(Compressed)</span></span>
                    </div>
                `;

                document.getElementById('det-crc').textContent = '0x' + (file.crc >>> 0).toString(16).toUpperCase();
                document.getElementById('det-method').textContent = file.method === 0 ? "STORED" : (file.method === 8 ? "DEFLATE" : `UNK (${file.method})`);

                const btn = document.getElementById('det-download-btn');
                const isSupported = file.method === 0 || file.method === 8;
                btn.disabled = !isSupported;
                btn.onclick = () => downloadFile(id);
                btn.textContent = isSupported ? "INITIALIZE DOWNLOAD" : "METHOD NOT SUPPORTED";

                const plBtn = document.getElementById('det-payload-btn');
                if (file.name.endsWith('payload.bin')) {
                    plBtn.style.display = 'block';
                    plBtn.onclick = () => initPayloadMode(file);
                } else {
                    plBtn.style.display = 'none';
                }

                toggleOverlay('details-overlay', true);
            }

            let CURRENT_BOOT_BLOB = null;
            function showDownloadCompleteUI(blobUrl, filename) {
                activeBlobUrl = blobUrl;

                const spinner = document.getElementById('progSpinner');
                const pText = document.getElementById('progressText');
                const pDet = document.getElementById('progressDetail');
                const btnContainer = document.getElementById('progBtnContainer');
                const saveBtn = document.getElementById('progSaveBtn');
                const closeBtn = document.getElementById('progCloseBtn');
                const cancelParseBtn = document.getElementById('progCancelParseBtn');
                const progressBox = document.querySelector('.progress-box');

                spinner.style.display = 'none';
                cancelParseBtn.style.display = 'none';

                pText.innerHTML = `COMPLETED<br><span style="font-size:0.8rem; color:var(--system-accent-color); font-weight:normal;">${filename}</span>`;
                pText.style.color = "var(--text-color)";
                pDet.innerText = "Ready to save.";

                btnContainer.style.display = 'flex';
                saveBtn.style.display = 'block';
                closeBtn.style.display = 'block';
                saveBtn.innerText = "SAVE FILE";

                saveBtn.onclick = () => {
                    const a = document.createElement('a');
                    a.href = blobUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
                ;

                closeBtn.onclick = () => {
                    if (activeBlobUrl) {
                        URL.revokeObjectURL(activeBlobUrl);
                        activeBlobUrl = null;
                    }
                    toggleOverlay('progressModal', false);
                }
                ;

                const oldUnpack = document.getElementById('progUnpackBtn');
                if (oldUnpack)
                    oldUnpack.remove();

                if (filename.match(/^(boot|recovery|init_boot|vendor_boot).*\.img$/i)) {
                    const unpackBtn = document.createElement('button');
                    unpackBtn.id = 'progUnpackBtn';
                    unpackBtn.className = 'sys-btn';
                    unpackBtn.style.width = '100%';
                    unpackBtn.style.marginTop = '15px';
                    unpackBtn.style.borderColor = 'var(--accent-blue)';
                    unpackBtn.style.color = 'var(--accent-blue)';
                    unpackBtn.innerHTML = "UNPACK / INSPECT";

                    unpackBtn.onmouseenter = function() {
                        this.style.background = 'var(--accent-blue)';
                        this.style.color = '#000';
                    }
                    ;
                    unpackBtn.onmouseleave = function() {
                        this.style.background = 'transparent';
                        this.style.color = 'var(--accent-blue)';
                    }
                    ;

                    unpackBtn.onclick = async () => {
                        try {
                            const r = await fetch(blobUrl);
                            const b = await r.blob();
                            CURRENT_BOOT_BLOB = b;
                            inspectBootImage(b, filename);
                        } catch (e) {
                            alert("Inspection Failed: " + e.message);
                        }
                    }
                    ;
                    progressBox.appendChild(unpackBtn);
                }
            }

            async function downloadFile(id) {
                const file = FILE_LIST.find(f => f.id === id);
                if (!file)
                    return;

                if (activeBlobUrl) {
                    URL.revokeObjectURL(activeBlobUrl);
                    activeBlobUrl = null;
                }
                toggleOverlay('details-overlay', false);
                resetProgressModalUI();
                toggleOverlay('progressModal', true);

                const pText = document.getElementById('progressText');
                const pDet = document.getElementById('progressDetail');
                const pFill = document.getElementById('progressBarFill');

                try {
                    pText.innerHTML = `DOWNLOADING<br><span style="font-size:0.8rem; color:var(--system-accent-color); font-weight:normal;">${file.name.split('/').pop()}</span>`;
                    pDet.innerText = "Reading File Header...";

                    const headerBuffer = await fetchBytes(CURRENT_URL, file.localOffset, file.localOffset + 255);
                    const view = new DataView(headerBuffer);
                    if (view.getUint32(0, true) !== LFH_SIG)
                        throw new Error("Header Sync Error. File may be encrypted or offset wrong.");

                    const nameLen = view.getUint16(26, true);
                    const extraLen = view.getUint16(28, true);
                    const dataStart = file.localOffset + 30 + nameLen + extraLen;
                    const dataEnd = dataStart + file.compSize - 1;

                    pDet.innerText = `Starting stream...`;

                    const compressedData = await fetchBytesWithProgress(CURRENT_URL, dataStart, dataEnd, (loaded, total) => {
                        const pct = Math.round((loaded / total) * 100);
                        pFill.style.width = `${pct}%`;
                        const loadedStr = (loaded / (1024 * 1024)).toFixed(2);
                        const totalStr = (total / (1024 * 1024)).toFixed(2);
                        pDet.innerText = `${pct}% | ${loadedStr} MB / ${totalStr} MB`;
                    }
                    );

                    let finalData;
                    if (file.method === 0)
                        finalData = compressedData;
                    else if (file.method === 8) {
                        pText.innerHTML = `DECOMPRESSING<br><span style="font-size:0.8rem; color:var(--system-accent-color); font-weight:normal;">${file.name.split('/').pop()}</span>`;
                        pDet.innerText = "Inflating Stream...";
                        pFill.style.width = '100%';
                        await new Promise(r => setTimeout(r, 50));

                        const blob = new Blob([compressedData]);
                        const ds = new DecompressionStream("deflate-raw");
                        const stream = blob.stream().pipeThrough(ds);
                        finalData = await new Response(stream).arrayBuffer();
                    }

                    pText.innerHTML = `VERIFYING<br><span style="font-size:0.8rem; color:var(--system-accent-color); font-weight:normal;">CRC32 CHECKSUM</span>`;
                    pDet.innerText = "Calculating Hash...";
                    await new Promise(r => setTimeout(r, 50));

                    const calculatedCrc = crc32(finalData);
                    if (calculatedCrc !== file.crc) {
                        throw new Error(`Integrity Check Failed!\nExpected: 0x${(file.crc >>> 0).toString(16)}\nCalculated: 0x${(calculatedCrc >>> 0).toString(16)}`);
                    }

                    pText.innerText = "PREPARING SAVE";
                    const saveBlob = new Blob([finalData]);
                    const url = URL.createObjectURL(saveBlob);

                    showDownloadCompleteUI(url, file.name.split('/').pop());

                } catch (e) {
                    console.error(e);
                    document.getElementById('progSpinner').style.display = 'none';
                    pText.innerText = "FAILED";
                    pText.style.color = "var(--accent-red)";
                    pDet.innerText = "Operation stopped.";

                    const log = document.getElementById('progLog');
                    log.style.display = 'block';
                    log.innerHTML = `<div style="color:#ff5555">ERROR: ${e.message}</div>`;

                    const btnCont = document.getElementById('progBtnContainer');
                    const saveBtn = document.getElementById('progSaveBtn');
                    const closeBtn = document.getElementById('progCloseBtn');

                    btnCont.style.display = 'flex';
                    saveBtn.style.display = 'none';
                    closeBtn.style.display = 'block';

                    closeBtn.onclick = () => {
                        if (activeBlobUrl) {
                            URL.revokeObjectURL(activeBlobUrl);
                            activeBlobUrl = null;
                        }
                        toggleOverlay('progressModal', false);
                    }
                    ;
                }
            }

            window.addEventListener('DOMContentLoaded', () => {
                generateThemeGrid();
                applyTheme(localStorage.getItem('peek_theme') || 'dark');
                const now = new Date();
                document.getElementById('date-display').textContent = now.toLocaleDateString('en-US', {
                    weekday: 'short',
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }).toUpperCase();
            }
            );

            const cursor = document.getElementById('custom-cursor');
            let mouseX = 0
              , mouseY = 0
              , cursorX = 0
              , cursorY = 0;
            const speed = 0.16;
            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
            );

            document.body.addEventListener('mouseover', (e) => {
                if (e.target.closest('button, .card, input, .upload-area, .human-item, .toggle-chip, tr, .mini-btn, th, .select-head, .select-option, .custom-chk')) {
                    document.body.classList.add('hovering');
                } else {
                    document.body.classList.remove('hovering');
                }
            }
            );

            function animateCursor() {
                cursorX += (mouseX - cursorX) * speed;
                cursorY += (mouseY - cursorY) * speed;
                const dist = Math.sqrt(Math.pow(mouseX - cursorX, 2) + Math.pow(mouseY - cursorY, 2));
                const scale = Math.min(dist / 100, 0.4);
                const angle = Math.atan2(mouseY - cursorY, mouseX - cursorX) * 180 / Math.PI;
                cursor.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0) translate(-50%, -50%) rotate(${angle}deg) scale(${1 + scale}, ${1 - scale * 0.5})`;
                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            const Me = ['PeekXtract By ArKT', 'Web Version v3.0', 'ArKT-7', 'ArKT_7'];
            const MeContainer = document.getElementById('me-display');
            async function typeWriterLoop() {
                while (true) {
                    for (let name of Me) {
                        MeContainer.textContent = "";
                        for (let char of name) {
                            MeContainer.textContent += char;
                            await new Promise(r => setTimeout(r, 50));
                        }
                        await new Promise(r => setTimeout(r, 3000));
                    }
                }
            }
            typeWriterLoop();

            function resetProgressModalUI() {
                const pFill = document.getElementById('progressBarFill');
                const pText = document.getElementById('progressText');
                const pDet = document.getElementById('progressDetail');
                const spinner = document.getElementById('progSpinner');
                const btnContainer = document.getElementById('progBtnContainer');
                const log = document.getElementById('progLog');
                const cancelBtn = document.getElementById('progCancelParseBtn');
                pFill.style.transition = 'none';
                pFill.style.width = '0%';
                void pFill.offsetWidth;
                pFill.style.transition = 'width 0.1s linear';
                pText.innerText = "PREPARING";
                pText.style.color = "var(--text-color)";
                pDet.innerText = "Initializing...";
                spinner.style.display = 'block';
                btnContainer.style.display = 'none';
                log.style.display = 'none';
                cancelBtn.style.display = 'none';
            }

            const PROTO = {
                "nested": {
                    "DeltaArchiveManifest": {
                        "fields": {
                            "block_size": {
                                "type": "uint32",
                                "id": 3
                            },
                            "partitions": {
                                "rule": "repeated",
                                "type": "PartitionUpdate",
                                "id": 13
                            }
                        }
                    },
                    "PartitionInfo": {
                        "fields": {
                            "size": {
                                "type": "uint64",
                                "id": 1
                            },
                            "hash": {
                                "type": "bytes",
                                "id": 2
                            }
                        }
                    },
                    "PartitionUpdate": {
                        "fields": {
                            "partitionName": {
                                "type": "string",
                                "id": 1
                            },
                            "newPartitionInfo": {
                                "type": "PartitionInfo",
                                "id": 7
                            },
                            "operations": {
                                "rule": "repeated",
                                "type": "InstallOperation",
                                "id": 8
                            }
                        }
                    },
                    "InstallOperation": {
                        "fields": {
                            "type": {
                                "type": "uint32",
                                "id": 1
                            },
                            "dataOffset": {
                                "type": "uint64",
                                "id": 2
                            },
                            "dataLength": {
                                "type": "uint64",
                                "id": 3
                            },
                            "dataSha256": {
                                "type": "bytes",
                                "id": 4
                            },
                            "dstExtents": {
                                "rule": "repeated",
                                "type": "Extent",
                                "id": 6
                            }
                        }
                    },
                    "Extent": {
                        "fields": {
                            "startBlock": {
                                "type": "uint64",
                                "id": 1
                            },
                            "numBlocks": {
                                "type": "uint64",
                                "id": 2
                            }
                        }
                    }
                }
            };

            const toNum = (n) => (n && n.low !== undefined) ? n.low + (n.high * 4294967296) : (Number(n) || 0);

            async function initPayloadMode(file, isAutoDetect=false) {
                toggleOverlay('details-overlay', false);
                if (globalAbortController) {
                    globalAbortController.abort();
                    globalAbortController = null;
                }

                resetProgressModalUI();
                toggleOverlay('progressModal', true);

                const pText = document.getElementById('progressText');
                const pFill = document.getElementById('progressBarFill');
                const pDet = document.getElementById('progressDetail');
                const pLog = document.getElementById('progLog');
                const btnContainer = document.getElementById('progBtnContainer');
                const spinner = document.getElementById('progSpinner');
                const cancelBtn = document.getElementById('progCancelParseBtn');
                const closeBtn = document.getElementById('progCloseBtn');
                const saveBtn = document.getElementById('progSaveBtn');

                if (isAutoDetect) {
                    pText.innerText = "AUTO DETECTED PAYLOAD";
                    pText.style.color = "var(--system-accent-color)";
                } else {
                    pText.innerText = "PARSING PAYLOAD";
                    pText.style.color = "var(--text-color)";
                }
                pFill.style.width = "69%";
                pLog.style.display = 'none';
                btnContainer.style.display = 'none';
                spinner.style.display = 'block';
                cancelBtn.style.display = 'block';
                cancelBtn.innerText = "CANCEL";

                globalAbortController = new AbortController();
                const signal = globalAbortController.signal;

                cancelBtn.onclick = () => {
                    if (globalAbortController) {
                        globalAbortController.abort();
                        globalAbortController = null;
                    }
                    toggleOverlay('progressModal', false);
                    setSystemMsg("Payload parsing cancelled by user.");
                }
                ;

                try {
                    if (file.method !== 0)
                        throw new Error("Payload is compressed in ZIP. Cannot seek.");

                    const lhBuf = await fetchBytes(CURRENT_URL, file.localOffset, file.localOffset + 512, signal);
                    const lhView = new DataView(lhBuf);
                    if (lhView.getUint32(0, true) !== LFH_SIG)
                        throw new Error("Local Header Error");

                    const lnLen = lhView.getUint16(26, true);
                    const lxLen = lhView.getUint16(28, true);
                    const payloadStart = file.localOffset + 30 + lnLen + lxLen;

                    const MAGIC = "CrAU";
                    const hBuf = await fetchBytes(CURRENT_URL, payloadStart, payloadStart + 256, signal);
                    const hView = new DataView(hBuf);
                    if (new TextDecoder().decode(new Uint8Array(hBuf,0,4)) !== MAGIC)
                        throw new Error("Not a valid Payload");

                    let ver = hView.getBigUint64(4, false);
                    let mLen = Number(hView.getBigUint64(12, false));
                    let sLen = Number(ver) >= 2 ? hView.getUint32(20, false) : 0;
                    const hdrSz = Number(ver) >= 2 ? 24 : 20;

                    const mBuf = await fetchBytes(CURRENT_URL, payloadStart + hdrSz, payloadStart + hdrSz + mLen - 1, signal);

                    const root = protobuf.Root.fromJSON(PROTO);
                    const Type = root.lookupType("DeltaArchiveManifest");
                    const msg = Type.decode(new Uint8Array(mBuf));
                    const obj = Type.toObject(msg, {
                        defaults: true,
                        longs: Number
                    });

                    PAYLOAD_INFO = {
                        dataOffset: payloadStart + hdrSz + mLen + sLen,
                        blockSize: obj.blockSize || 4096
                    };
                    PARTITIONS = obj.partitions || [];

                    document.getElementById('fileSearch').value = '';
                    sortState = {
                        key: 'id',
                        dir: 'asc'
                    };
                    ['id', 'name', 'size'].forEach(k => {
                        const icon = document.getElementById(`sort-${k}`);
                        if (icon) {
                            icon.textContent = '';
                            icon.parentElement.classList.remove('active-sort');
                        }
                    }
                    );

                    renderPayloadTable(PARTITIONS);
                    toggleOverlay('progressModal', false);

                } catch (e) {
                    if (e.name === 'AbortError') {
                        console.log("Fetch aborted");
                        return;
                    }

                    console.error(e);

                    pDet.innerText = "Error";
                    pLog.style.display = 'block';
                    pLog.innerHTML = `<div style="color:#ff5555">ERROR: ${e.message}</div>`;

                    cancelBtn.style.display = 'none';
                    btnContainer.style.display = 'flex';
                    saveBtn.style.display = 'none';
                    closeBtn.style.display = 'block';

                    closeBtn.onclick = () => toggleOverlay('progressModal', false);
                }
            }

            function renderPayloadTable(list) {
                IS_PAYLOAD_VIEW = true;
                if (!list)
                    list = PARTITIONS;
                document.getElementById('listTitle').innerText = "SYSTEM PARTITIONS";
                document.getElementById('fileCountBadge').innerText = `${list.length} PARTITIONS`;
                document.getElementById('backBtn').classList.add('visible');

                const tbody = document.getElementById('fileTableBody');
                const totalCount = list.length;
                tbody.innerHTML = list.map( (p, index) => {
                    const originalIdx = PARTITIONS.indexOf(p);
                    let displayId;
                    if (sortState.dir === 'desc') {
                        displayId = totalCount - index;
                    } else {
                        displayId = index + 1;
                    }

                    let size = toNum(p.newPartitionInfo?.size || 0);

                    if (!size) {
                        let totalBlocks = 0;
                        const ops = p.operations || [];
                        ops.forEach(op => {
                            if (op.dstExtents) {
                                op.dstExtents.forEach(e => totalBlocks += toNum(e.numBlocks));
                            }
                        }
                        );
                        size = totalBlocks * PAYLOAD_INFO.blockSize;
                    }

                    return `
            <tr onclick="openPartitionDetails(${originalIdx})">
                <td class="col-id">#${String(displayId).padStart(3, '0')}</td>
                <td class="col-name" style="color:var(--system-accent-color); font-weight:bold;">${p.partitionName}.img</td>
                <td class="col-size">${formatSize(size)}</td>
                <td class="col-action">
                    <button class="mini-btn" onclick="event.stopPropagation(); extractPartition(${originalIdx})">‚á©</button>
                </td>
            </tr>`;
                }
                ).join('');
            }

            function openPartitionDetails(idx) {
                if (!IS_PAYLOAD_VIEW) {
                    const file = FILE_LIST.find(f => f.id === idx);
                    if (!file)
                        return;
                    document.getElementById('det-name').textContent = file.name.split('/').pop();
                    document.getElementById('det-path').textContent = file.name;
                    document.getElementById('det-size').textContent = formatSize(file.size);
                    document.getElementById('det-crc').textContent = '0x' + (file.crc >>> 0).toString(16).toUpperCase();
                    document.getElementById('det-method').textContent = file.method === 0 ? "STORED" : (file.method === 8 ? "DEFLATE" : `UNK (${file.method})`);

                    const btn = document.getElementById('det-download-btn');
                    const isSupported = file.method === 0 || file.method === 8;
                    btn.disabled = !isSupported;
                    btn.onclick = () => downloadFile(idx);
                    btn.textContent = isSupported ? "INITIALIZE DOWNLOAD" : "METHOD NOT SUPPORTED";

                    const plBtn = document.getElementById('det-payload-btn');
                    if (file.name.endsWith('payload.bin')) {
                        plBtn.style.display = 'block';
                        plBtn.onclick = () => initPayloadMode(file);
                    } else {
                        plBtn.style.display = 'none';
                    }
                    toggleOverlay('details-overlay', true);
                    return;
                }

                const label = document.getElementById('det-hash-label');
                if (label)
                    label.textContent = "SHA-256";

                const p = PARTITIONS[idx];
                document.getElementById('det-name').textContent = `${p.partitionName}.img`;
                document.getElementById('det-path').textContent = `payload.bin :: ${p.partitionName}`;

                let hashStr = "N/A";
                try {
                    if (p.newPartitionInfo && p.newPartitionInfo.hash) {
                        const raw = p.newPartitionInfo.hash;
                        const bytes = (raw instanceof Uint8Array) ? raw : new Uint8Array(raw);

                        hashStr = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
                    }
                } catch (e) {
                    console.warn("Hash extraction failed:", e);
                    hashStr = "HASH ERROR";
                }
                document.getElementById('det-crc').textContent = hashStr;

                let actualSize = toNum(p.newPartitionInfo?.size || 0);
                if (!actualSize) {
                    let totalBlocks = 0;
                    (p.operations || []).forEach(op => {
                        if (op.dstExtents)
                            op.dstExtents.forEach(e => totalBlocks += toNum(e.numBlocks));
                    }
                    );
                    actualSize = totalBlocks * PAYLOAD_INFO.blockSize;
                }

                let compressedSize = 0;
                (p.operations || []).forEach(op => {
                    compressedSize += toNum(op.dataLength || 0);
                }
                );

                document.getElementById('det-size').innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:2px;">
                        <span>${formatSize(actualSize)} <span style="color:var(--text-dim); font-size:0.8em;">(Actual)</span></span>
                        <span style="color:var(--system-accent-color); font-size:0.9em;">${formatSize(compressedSize)} <span style="opacity:0.7; font-size:0.9em;">(Download)</span></span>
                    </div>
                `;

                document.getElementById('det-method').textContent = "XZ / BROTLI / RAW";

                const btn = document.getElementById('det-download-btn');
                btn.textContent = "EXTRACT PARTITION";
                btn.disabled = false;
                btn.onclick = () => extractPartition(idx);

                document.getElementById('det-payload-btn').style.display = 'none';
                toggleOverlay('details-overlay', true);
            }

            function restoreZipView() {
                IS_PAYLOAD_VIEW = false;
                document.getElementById('fileSearch').value = '';
                sortState = {
                    key: 'id',
                    dir: 'asc'
                };
                ['id', 'name', 'size'].forEach(k => {
                    const icon = document.getElementById(`sort-${k}`);
                    if (icon) {
                        icon.textContent = '';
                        icon.parentElement.classList.remove('active-sort');
                    }
                }
                );
                renderFiles(FILE_LIST);
            }

            async function extractPartition(idx) {
                if (activeBlobUrl) {
                    URL.revokeObjectURL(activeBlobUrl);
                    activeBlobUrl = null;
                }
                toggleOverlay('details-overlay', false);
                resetProgressModalUI();
                toggleOverlay('progressModal', true);

                const controller = new AbortController();
                const signal = controller.signal;

                const p = PARTITIONS[idx];
                const ops = p.operations || [];
                const name = p.partitionName;
                const blockSz = PAYLOAD_INFO.blockSize || 4096;
                const fileName = `${name}.img`;

                const pFill = document.getElementById('progressBarFill');
                const pText = document.getElementById('progressText');
                const pDet = document.getElementById('progressDetail');
                const pLog = document.getElementById('progLog');

                pText.innerHTML = `EXTRACTING <span style="color:var(--system-accent-color);">${fileName}</span>`;

                try {
                    if (!window.xzwasm)
                        throw new Error("XZ Library not loaded");
                    if (!window.bzip2)
                        console.warn("Bzip2 Library not loaded. REPLACE_BZ operations will fail.");

                    const opTypes = {};
                    ops.forEach(op => {
                        opTypes[op.type] = (opTypes[op.type] || 0) + 1;
                    }
                    );
                    const differentialOps = (opTypes[4] || 0) + (opTypes[5] || 0);

                    if (differentialOps > 0) {
                        pLog.style.display = 'block';
                        pLog.innerHTML = `<div style="color:orange; border-bottom:1px solid #333; padding-bottom:5px; margin-bottom:5px;">
                            <strong>WARNING: INCREMENTAL UPDATE DETECTED</strong><br>
                            This partition requires the original file from the phone to update correctly.<br>
                            We will extract what we can, but the final hash <strong>WILL NOT MATCH</strong>.
                        </div>`;
                    }

                    let exactSize = toNum(p.newPartitionInfo?.size || 0);
                    if (exactSize === 0) {
                        let totalBlocks = 0;
                        ops.forEach(op => {
                            if (op.dstExtents)
                                op.dstExtents.forEach(e => totalBlocks += toNum(e.numBlocks));
                        }
                        );
                        exactSize = totalBlocks * blockSz;
                    }

                    pDet.innerText = `Allocating ${formatSize(exactSize)}...`;
                    const finalBuffer = new Uint8Array(exactSize);

                    const fetchChunk = async (start, end, expectedSha256, signal, retries=5) => {
                        const len = end - start + 1;

                        if (LOCAL_FILE) {
                            const slice = LOCAL_FILE.slice(start, end + 1);
                            const buf = await slice.arrayBuffer();

                            if (expectedSha256 && expectedSha256.length > 0) {
                                const hashBuf = await crypto.subtle.digest('SHA-256', buf);
                                const actual = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
                                const expect = Array.from(expectedSha256).map(b => b.toString(16).padStart(2, '0')).join('');
                                if (actual !== expect)
                                    throw new Error("Chunk Hash Mismatch");
                            }
                            return new Uint8Array(buf);
                        }

                        for (let i = 0; i < retries; i++) {
                            try {
                                const bust = `&t=${Date.now()}`;
                                const url = getTargetUrl(CURRENT_URL) + (CURRENT_URL.includes('?') ? bust : '?cb=1' + bust);
                                const headers = getRequestHeaders(start, end);

                                const resp = await fetch(url, {
                                    headers: headers,
                                    signal: signal
                                });

                                if (resp.status === 200)
                                    throw new Error("PROXY_FAIL");
                                if (!resp.ok && resp.status !== 206)
                                    throw new Error(`HTTP ${resp.status}`);
                                const buf = await resp.arrayBuffer();
                                if (buf.byteLength !== len)
                                    throw new Error(`Partial chunk: ${buf.byteLength}/${len}`);

                                if (expectedSha256 && expectedSha256.length > 0) {
                                    const hashBuf = await crypto.subtle.digest('SHA-256', buf);
                                    const actual = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
                                    const expect = Array.from(expectedSha256).map(b => b.toString(16).padStart(2, '0')).join('');
                                    if (actual !== expect)
                                        throw new Error("Chunk Hash Mismatch");
                                }
                                return new Uint8Array(buf);
                            } catch (e) {
                                if (e.name === 'AbortError')
                                    throw e;
                                if (e.message === "PROXY_FAIL")
                                    throw e;
                                console.warn(`Retry ${i + 1}/${retries}: ${e.message}`);
                                if (i === retries - 1)
                                    throw e;
                                await new Promise(r => setTimeout(r, 1000 * (i + 1)));
                            }
                        }
                    }
                    ;

                    const activeOps = ops.filter(op => [0, 1, 8].includes(op.type));
                    let totalBytes = 0;
                    activeOps.forEach(op => totalBytes += toNum(op.dataLength || 0));

                    let loadedBytes = 0;
                    let processedChunks = 0;
                    const totalChunks = ops.length;

                    for (let i = 0; i < ops.length; i++) {
                        const op = ops[i];
                        const dOff = toNum(op.dataOffset);
                        const dLen = toNum(op.dataLength);

                        if ([0, 1, 8].includes(op.type) && dLen > 0) {
                            const absStart = PAYLOAD_INFO.dataOffset + dOff;
                            const absEnd = absStart + dLen - 1;
                            let data = await fetchChunk(absStart, absEnd, op.dataSha256, signal);
                            loadedBytes += data.length;

                            if (op.type === 8) {
                                try {
                                    const blob = new Blob([data]);
                                    const stream = new window.xzwasm.XzReadableStream(blob.stream());
                                    data = new Uint8Array(await new Response(stream).arrayBuffer());
                                } catch (e) {
                                    throw new Error(`XZ Decompression failed: ${e.message}`);
                                }
                            } else if (op.type === 1) {
                                try {
                                    if (window.bzip2) {
                                        const bitstream = bzip2.array(data);
                                        const str = bzip2.simple(bitstream);
                                        data = new Uint8Array(str.length);
                                        for (let k = 0; k < str.length; k++)
                                            data[k] = str.charCodeAt(k);
                                    } else {
                                        throw new Error("Bzip2 library missing");
                                    }
                                } catch (e) {
                                    throw new Error(`Bzip2 Decompression failed: ${e.message}`);
                                }
                            }

                            if (op.dstExtents) {
                                let ptr = 0;
                                for (const ext of op.dstExtents) {
                                    const destStart = toNum(ext.startBlock) * blockSz;
                                    const destLen = toNum(ext.numBlocks) * blockSz;
                                    const toWrite = Math.min(destLen, data.length - ptr);
                                    if (toWrite <= 0)
                                        break;
                                    if (destStart < finalBuffer.length) {
                                        finalBuffer.set(data.subarray(ptr, ptr + toWrite), destStart);
                                    }
                                    ptr += toWrite;
                                }
                            }
                        }

                        processedChunks++;
                        const byteRatio = totalBytes > 0 ? (loadedBytes / totalBytes) : 0;
                        const chunkRatio = processedChunks / totalChunks;
                        const weightedPct = (byteRatio * 70) + (chunkRatio * 30);
                        pFill.style.width = `${weightedPct}%`;
                        const pctText = `${Math.floor(weightedPct)}%`;

                        if (weightedPct < 70) {
                            const mbLoaded = (loadedBytes / (1024 * 1024)).toFixed(1);
                            const mbTotal = (totalBytes / (1024 * 1024)).toFixed(1);
                            pDet.innerText = `${pctText} | ${mbLoaded} MB / ${mbTotal} MB`;
                        } else {
                            pDet.innerHTML = `${pctText} | Processing Chunk <span style="color:var(--system-accent-color);">${processedChunks}</span> / ${totalChunks}`;
                        }
                        await new Promise(r => setTimeout(r, 0));
                    }

                    pFill.style.transition = 'none';
                    pFill.style.width = '100%';
                    pText.innerHTML = `VERIFYING <span style="color:var(--system-accent-color);">INTEGRITY</span>`;
                    pDet.innerText = "Calculating SHA-256 Hash...";

                    await new Promise(r => setTimeout(r, 50));

                    if (p.newPartitionInfo?.hash) {
                        const finalHashBuf = await crypto.subtle.digest('SHA-256', finalBuffer);
                        const actualHash = Array.from(new Uint8Array(finalHashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
                        const expectHash = Array.from(p.newPartitionInfo.hash).map(b => b.toString(16).padStart(2, '0')).join('');

                        if (actualHash !== expectHash) {
                            const msg = differentialOps > 0 ? "Expected mismatch (Incremental Update)." : "Mismatch detected.";
                            pLog.style.display = 'block';
                            pLog.innerHTML += `<div style="color:${differentialOps > 0 ? 'orange' : '#ff5555'}; margin-top:5px;">Hash Mismatch.<br>Expect: ${expectHash.substr(0, 8)}...<br>Actual: ${actualHash.substr(0, 8)}...<br>${msg}</div>`;
                        } else {
                            setSystemMsg("Integrity Verified: Hash Matches.", false);
                        }
                    }

                    pText.innerText = "COMPLETED";
                    pText.style.color = "var(--system-accent-color)";
                    const blob = new Blob([finalBuffer],{
                        type: "application/octet-stream"
                    });
                    const u = URL.createObjectURL(blob);
                    showDownloadCompleteUI(u, fileName);

                } catch (e) {
                    controller.abort();
                    console.error(e);
                    document.getElementById('progSpinner').style.display = 'none';
                    pText.innerHTML = `FAILED<br><span style="font-size:0.8rem; color:var(--text-dim); font-weight:normal;">${fileName}</span>`;
                    pText.style.color = "var(--accent-red)";
                    pLog.style.display = 'block';

                    if (e.message === "PROXY_FAIL") {
                        pLog.innerHTML += `<div style="color:#ff5555; font-weight:bold;">
                            PROXY ERROR DETECTED!<br>
                            The proxy returned the WHOLE file instead of the requested part.<br>
                            <br>
                            SOLUTION:<br>
                            1. Launch browser with CORS disabled.<br>
                            2. Uncheck "ENABLE PROXY"<br>
                            3. Try again.
                        </div>`;
                    } else {
                        pLog.innerHTML += `<div style="color:#ff5555">${e.message}</div>`;
                    }

                    document.getElementById('progBtnContainer').style.display = 'flex';
                    const retryBtn = document.getElementById('progSaveBtn');
                    retryBtn.innerText = "RETRY";
                    retryBtn.onclick = () => extractPartition(idx);
                    document.getElementById('progCloseBtn').onclick = () => {
                        if (activeBlobUrl) {
                            URL.revokeObjectURL(activeBlobUrl);
                            activeBlobUrl = null;
                        }
                        toggleOverlay('progressModal', false);
                    }
                    ;
                }
            }

            async function inspectBootImage(blob, filename) {
                const reader = new FileReader();
                reader.onload = function() {
                    try {
                        const buf = this.result;
                        const view = new DataView(buf);
                        const decoder = new TextDecoder();
                        const magic = decoder.decode(new Uint8Array(buf,0,8));

                        let headerVersion = 0
                          , pageSize = 2048
                          , kernelSz = 0
                          , ramdiskSz = 0
                          , secondSz = 0
                          , recDtboSz = 0
                          , dtbSz = 0;
                        const infoGrid = document.getElementById('boot-info-grid');
                        const tableBody = document.getElementById('boot-components-body');
                        const cmdDiv = document.getElementById('boot-cmdline');
                        const cmdContainer = document.getElementById('boot-cmdline-container');
                        let components = [];

                        const getPad = (sz, pg) => (sz + pg - 1) & ~(pg - 1);

                        if (magic === "ANDROID!") {
                            const verCheck = view.getUint32(40, true);

                            if (verCheck === 3 || verCheck === 4) {
                                headerVersion = verCheck;
                                pageSize = 4096;
                                kernelSz = view.getUint32(8, true);
                                ramdiskSz = view.getUint32(12, true);

                                let currentPos = 4096;
                                if (kernelSz > 0) {
                                    components.push({
                                        name: 'kernel',
                                        start: currentPos,
                                        size: kernelSz
                                    });
                                    currentPos += getPad(kernelSz, pageSize);
                                }
                                if (ramdiskSz > 0) {
                                    components.push({
                                        name: 'ramdisk.cpio',
                                        start: currentPos,
                                        size: ramdiskSz
                                    });
                                    currentPos += getPad(ramdiskSz, pageSize);
                                }

                                const cmdBuf = new Uint8Array(buf,44,1536);
                                cmdDiv.textContent = decoder.decode(cmdBuf).replace(/\0/g, '').trim();

                            } else {
                                headerVersion = view.getUint32(44, true);
                                pageSize = view.getUint32(36, true);
                                kernelSz = view.getUint32(8, true);
                                ramdiskSz = view.getUint32(16, true);
                                secondSz = view.getUint32(24, true);

                                if (headerVersion >= 1)
                                    recDtboSz = view.getUint32(1632 + 4, true);
                                if (headerVersion >= 2)
                                    dtbSz = view.getUint32(1632 + 16, true);

                                let currentPos = pageSize;
                                if (kernelSz > 0) {
                                    components.push({
                                        name: 'kernel',
                                        start: currentPos,
                                        size: kernelSz
                                    });
                                    currentPos += getPad(kernelSz, pageSize);
                                }
                                if (ramdiskSz > 0) {
                                    components.push({
                                        name: 'ramdisk.cpio',
                                        start: currentPos,
                                        size: ramdiskSz
                                    });
                                    currentPos += getPad(ramdiskSz, pageSize);
                                }
                                if (secondSz > 0) {
                                    components.push({
                                        name: 'second_stage',
                                        start: currentPos,
                                        size: secondSz
                                    });
                                    currentPos += getPad(secondSz, pageSize);
                                }
                                if (recDtboSz > 0) {
                                    components.push({
                                        name: 'recovery_dtbo',
                                        start: currentPos,
                                        size: recDtboSz
                                    });
                                    currentPos += getPad(recDtboSz, pageSize);
                                }
                                if (dtbSz > 0) {
                                    components.push({
                                        name: 'dtb.img',
                                        start: currentPos,
                                        size: dtbSz
                                    });
                                    currentPos += getPad(dtbSz, pageSize);
                                }

                                const cmdBuf = new Uint8Array(buf,64,512);
                                let cmdStr = decoder.decode(cmdBuf).replace(/\0/g, '').trim();
                                if (headerVersion >= 1) {
                                    const extra = decoder.decode(new Uint8Array(buf,1088,1024)).replace(/\0/g, '').trim();
                                    if (extra)
                                        cmdStr += " " + extra;
                                }
                                cmdDiv.textContent = cmdStr;
                            }
                        } else if (magic === "VNDRBOOT") {
                            headerVersion = view.getUint32(4, true);
                            pageSize = view.getUint32(8, true);
                            ramdiskSz = view.getUint32(20, true);
                            dtbSz = view.getUint32(24, true);

                            let currentPos = pageSize;
                            if (ramdiskSz > 0) {
                                components.push({
                                    name: 'vendor_ramdisk',
                                    start: currentPos,
                                    size: ramdiskSz
                                });
                                currentPos += getPad(ramdiskSz, pageSize);
                            }
                            if (dtbSz > 0) {
                                components.push({
                                    name: 'dtb.img',
                                    start: currentPos,
                                    size: dtbSz
                                });
                                currentPos += getPad(dtbSz, pageSize);
                            }

                            cmdDiv.textContent = "Vendor Boot Config";
                        } else {
                            alert(`Unknown Magic: ${magic.substring(0, 8)}...`);
                            return;
                        }

                        const finalCmd = cmdDiv.textContent.trim();
                        if (finalCmd && finalCmd !== "" && finalCmd !== "(Empty)") {
                            cmdContainer.style.display = 'block';
                            if (finalCmd === "")
                                cmdDiv.textContent = "(Empty)";
                        } else {
                            cmdContainer.style.display = 'none';
                        }

                        infoGrid.innerHTML = `<div><span style="color:var(--text-dim)">MAGIC:</span> <span style="color:var(--system-accent-color)">${magic}</span></div><div><span style="color:var(--text-dim)">HEADER VER:</span> ${headerVersion}</div><div><span style="color:var(--text-dim)">PAGE SIZE:</span> ${pageSize}</div><div><span style="color:var(--text-dim)">KERNEL:</span> ${formatSize(kernelSz)}</div><div><span style="color:var(--text-dim)">RAMDISK:</span> ${formatSize(ramdiskSz)}</div><div><span style="color:var(--text-dim)">DTB/EXTRA:</span> ${formatSize(dtbSz || recDtboSz)}</div>`;
                        tableBody.innerHTML = components.map( (c, i) => `<tr><td style="color:var(--text-color); font-weight:bold;">${c.name}</td><td style="text-align:right; font-family:monospace;">${formatSize(c.size)}</td><td style="text-align:center;"><button class="mini-btn" onclick="extractBootComp(${i})">DOWNLOAD</button></td></tr>`).join('');

                        window.CURRENT_BOOT_MAP = components;
                        toggleOverlay('boot-overlay', true);

                    } catch (e) {
                        console.error(e);
                        alert("Parser Error: " + e.message);
                    }
                }
                ;
                reader.readAsArrayBuffer(blob.slice(0, 16384));
            }

            function extractBootComp(index) {
                if (!CURRENT_BOOT_BLOB || !window.CURRENT_BOOT_MAP)
                    return;
                const comp = window.CURRENT_BOOT_MAP[index];
                const slice = CURRENT_BOOT_BLOB.slice(comp.start, comp.start + comp.size);
                const url = URL.createObjectURL(slice);
                const a = document.createElement('a');
                a.href = url;
                a.download = comp.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        </script>
    </body>
</html>